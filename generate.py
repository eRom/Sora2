#!/usr/bin/env python3
"""
Script pour g√©n√©rer une vid√©o avec l'API Sora2
"""

import os
import sys
import requests
from dotenv import load_dotenv
from pathlib import Path
import time
import json
import hashlib

# Charger les variables d'environnement
load_dotenv()

# Configuration
API_KEY = os.getenv("SORA_API_KEY")
MODEL = os.getenv("SORA_MODEL", "sora-2-pro")
DURATION = os.getenv("SORA_DURATION", "8")
SIZE = os.getenv("SORA_SIZE", "1280x720")

# URL de l'API Sora2
API_BASE_URL = "https://api.openai.com/v1/videos"

# Configuration retry
MAX_RETRIES = 3
INITIAL_BACKOFF = 5  # secondes

def save_metadata(video_id, prompt, status, error=None):
    """Sauvegarde les m√©tadonn√©es de la vid√©o pour r√©cup√©ration ult√©rieure"""
    metadata_dir = Path("metadata")
    metadata_dir.mkdir(exist_ok=True)

    metadata = {
        "video_id": video_id,
        "prompt": prompt,
        "model": MODEL,
        "duration": DURATION,
        "size": SIZE,
        "status": status,
        "timestamp": int(time.time()),
        "error": error
    }

    metadata_file = metadata_dir / f"{video_id}.json"
    with open(metadata_file, "w", encoding="utf-8") as f:
        json.dump(metadata, f, indent=2, ensure_ascii=False)

    return metadata_file

def read_prompt():
    """Lit le prompt depuis le fichier prompt.md"""
    prompt_file = Path("prompt.md")
    if not prompt_file.exists():
        print("Erreur: Le fichier prompt.md n'existe pas")
        sys.exit(1)

    with open(prompt_file, "r", encoding="utf-8") as f:
        content = f.read().strip()
        # Retirer les titres markdown et lignes vides
        lines = [line for line in content.split("\n") if line.strip() and not line.startswith("#")]
        return "\n".join(lines)

def check_moderation_error(error_response):
    """D√©tecte si l'erreur est li√©e √† la mod√©ration"""
    if not error_response:
        return False

    error_text = str(error_response).lower()
    moderation_keywords = [
        "moderation",
        "content policy",
        "violates",
        "inappropriate",
        "blocked",
        "prohibited"
    ]

    return any(keyword in error_text for keyword in moderation_keywords)

def generate_video(prompt):
    """G√©n√®re une vid√©o en utilisant l'API Sora2"""
    if not API_KEY or API_KEY == "your_api_key_here":
        print("Erreur: Veuillez configurer votre cl√© API dans le fichier .env")
        sys.exit(1)

    headers = {
        "Authorization": f"Bearer {API_KEY}",
        "Content-Type": "application/json"
    }

    payload = {
        "model": MODEL,
        "prompt": prompt,
        "seconds": DURATION,
        "size": SIZE
    }

    print(f"G√©n√©ration de la vid√©o avec les param√®tres:")
    print(f"  - Model: {MODEL}")
    print(f"  - Duration: {DURATION}s")
    print(f"  - Size: {SIZE}")
    print(f"  - Prompt: {prompt[:100]}...")
    print("\nEnvoi de la requ√™te √† l'API...")

    try:
        response = requests.post(API_BASE_URL, headers=headers, json=payload)

        # V√©rifier les erreurs de mod√©ration AVANT de facturer
        if response.status_code == 400:
            error_data = response.json() if response.text else {}
            error_msg = error_data.get("error", {}).get("message", response.text)

            if check_moderation_error(error_msg):
                print("\n‚ùå ERREUR DE MOD√âRATION:")
                print(f"   {error_msg}")
                print("\nüí° Suggestions:")
                print("   - Reformulez votre prompt pour √©viter le contenu sensible")
                print("   - √âvitez les descriptions violentes, sexuelles ou inappropri√©es")
                print("   - Utilisez un langage plus neutre et descriptif")
                print("\n‚ö†Ô∏è  IMPORTANT: Vous n'avez PAS √©t√© d√©bit√© car la requ√™te a √©t√© rejet√©e avant la g√©n√©ration")
                return False
            else:
                print(f"\n‚ùå Erreur de requ√™te: {error_msg}")
                return False

        response.raise_for_status()
        result = response.json()
        print(f"R√©ponse de l'API: {result}")

        # L'API retourne un ID de vid√©o
        if "id" in result:
            video_id = result["id"]
            print(f"\n‚úì T√¢che de g√©n√©ration cr√©√©e: {video_id}")
            print("‚è≥ La g√©n√©ration peut prendre quelques minutes...")

            # Sauvegarder les m√©tadonn√©es
            save_metadata(video_id, prompt, "queued")

            return wait_for_completion(video_id, headers, prompt)

        print("Format de r√©ponse inattendu:", result)
        return False

    except requests.exceptions.RequestException as e:
        print(f"\n‚ùå Erreur lors de la requ√™te API: {e}")
        if hasattr(e, 'response') and e.response is not None:
            try:
                error_data = e.response.json()
                error_msg = error_data.get("error", {}).get("message", e.response.text)
                print(f"   D√©tails: {error_msg}")

                if check_moderation_error(error_msg):
                    print("\n‚ö†Ô∏è  Erreur de mod√©ration d√©tect√©e - Vous n'avez pas √©t√© d√©bit√©")
            except:
                print(f"   D√©tails: {e.response.text}")
        return False

def wait_for_completion(video_id, headers, prompt):
    """Attend la compl√©tion d'une t√¢che de g√©n√©ration asynchrone"""
    status_url = f"{API_BASE_URL}/{video_id}"
    content_url = f"{API_BASE_URL}/{video_id}/content"

    timeout_counter = 0
    max_timeout = 600  # 10 minutes (600 secondes / 10 secondes par check)

    while timeout_counter < max_timeout:
        try:
            response = requests.get(status_url, headers=headers)
            response.raise_for_status()
            result = response.json()

            status = result.get("status")
            progress = result.get("progress", 0)
            print(f"üìä Status: {status} - Progression: {progress}%")

            # Mettre √† jour les m√©tadonn√©es
            save_metadata(video_id, prompt, status)

            if status == "completed":
                print(f"\n‚úÖ Vid√©o g√©n√©r√©e avec succ√®s!")
                # T√©l√©charger la vid√©o avec retry
                return download_video_with_retry(content_url, headers, video_id, prompt)

            elif status in ["failed", "error"]:
                error_info = result.get("error", {})
                error_msg = error_info.get("message", "Erreur inconnue")
                error_code = error_info.get("code", "")

                print(f"\n‚ùå Erreur lors de la g√©n√©ration:")
                print(f"   Message: {error_msg}")
                if error_code:
                    print(f"   Code: {error_code}")

                # Sauvegarder l'erreur dans les m√©tadonn√©es
                save_metadata(video_id, prompt, "failed", error=error_msg)

                if check_moderation_error(error_msg):
                    print("\n‚ö†Ô∏è  ATTENTION: Vous avez √©t√© d√©bit√© mais la vid√©o a √©t√© rejet√©e par la mod√©ration")
                    print("   Contactez le support OpenAI pour un remboursement avec cet ID: " + video_id)

                return False

            time.sleep(10)
            timeout_counter += 1

        except requests.exceptions.RequestException as e:
            print(f"\n‚ö†Ô∏è  Erreur lors de la v√©rification du status: {e}")
            if hasattr(e, 'response') and hasattr(e.response, 'text'):
                print(f"   D√©tails: {e.response.text}")

            # Sauvegarder l'√©tat d'erreur
            save_metadata(video_id, prompt, "error", error=str(e))
            print(f"\nüíæ M√©tadonn√©es sauvegard√©es pour r√©cup√©ration: metadata/{video_id}.json")
            return False

    print(f"\n‚è∞ Timeout: La g√©n√©ration prend trop de temps (>{max_timeout * 10}s)")
    print(f"   Video ID: {video_id}")
    print(f"   Vous pouvez v√©rifier manuellement le statut plus tard")
    save_metadata(video_id, prompt, "timeout")
    return False

def download_video_with_retry(content_url, headers, video_id, prompt, max_retries=MAX_RETRIES):
    """T√©l√©charge la vid√©o avec retry en cas d'erreur r√©seau"""
    for attempt in range(max_retries):
        try:
            print(f"\nüì• Tentative de t√©l√©chargement {attempt + 1}/{max_retries}...")

            if download_video_from_api(content_url, headers, video_id):
                save_metadata(video_id, prompt, "downloaded")
                return True

        except Exception as e:
            wait_time = INITIAL_BACKOFF * (2 ** attempt)
            if attempt < max_retries - 1:
                print(f"\n‚ö†Ô∏è  Erreur: {e}")
                print(f"   Nouvelle tentative dans {wait_time}s...")
                time.sleep(wait_time)
            else:
                print(f"\n‚ùå √âchec apr√®s {max_retries} tentatives")
                print(f"   Video ID: {video_id}")
                print(f"   URL: {content_url}")
                print(f"\nüí° Vous pouvez t√©l√©charger manuellement avec:")
                print(f"   curl -H 'Authorization: Bearer YOUR_API_KEY' '{content_url}' > output/{video_id}.mp4")
                save_metadata(video_id, prompt, "download_failed", error=str(e))
                return False

    return False

def download_video_from_api(content_url, headers, video_id):
    """T√©l√©charge la vid√©o g√©n√©r√©e depuis l'API"""
    print("üì• T√©l√©chargement de la vid√©o...")

    response = requests.get(content_url, headers=headers, stream=True, timeout=300)
    response.raise_for_status()

    # Cr√©er le dossier de sortie si n√©cessaire
    output_dir = Path("output")
    output_dir.mkdir(exist_ok=True)

    # Nom du fichier avec timestamp
    timestamp = int(time.time())
    output_file = output_dir / f"video_{video_id}_{timestamp}.mp4"
    temp_file = output_dir / f"video_{video_id}_{timestamp}.mp4.tmp"

    total_size = int(response.headers.get('content-length', 0))
    downloaded = 0
    hasher = hashlib.sha256()

    # T√©l√©charger dans un fichier temporaire
    with open(temp_file, "wb") as f:
        for chunk in response.iter_content(chunk_size=8192):
            if chunk:
                f.write(chunk)
                hasher.update(chunk)
                downloaded += len(chunk)
                if total_size > 0:
                    progress = (downloaded / total_size) * 100
                    print(f"\rüì• T√©l√©chargement: {progress:.1f}% ({downloaded}/{total_size} bytes)", end="", flush=True)

    print()  # Nouvelle ligne apr√®s la barre de progression

    # V√©rifier que le t√©l√©chargement est complet
    if total_size > 0 and downloaded != total_size:
        temp_file.unlink()
        raise Exception(f"T√©l√©chargement incomplet: {downloaded}/{total_size} bytes")

    # V√©rifier que le fichier n'est pas vide
    if downloaded == 0:
        temp_file.unlink()
        raise Exception("Le fichier t√©l√©charg√© est vide")

    # Renommer le fichier temporaire
    temp_file.rename(output_file)

    file_hash = hasher.hexdigest()
    print(f"\n‚úÖ Vid√©o sauvegard√©e: {output_file}")
    print(f"   Taille: {downloaded:,} bytes")
    print(f"   SHA256: {file_hash[:16]}...")

    # Sauvegarder le hash dans les m√©tadonn√©es
    metadata_file = Path("metadata") / f"{video_id}.json"
    if metadata_file.exists():
        with open(metadata_file, "r") as f:
            metadata = json.load(f)
        metadata["file_path"] = str(output_file)
        metadata["file_size"] = downloaded
        metadata["sha256"] = file_hash
        with open(metadata_file, "w") as f:
            json.dump(metadata, f, indent=2, ensure_ascii=False)

    return True

def main():
    print("‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê")
    print("   üé¨ G√©n√©rateur de vid√©o Sora2")
    print("‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n")

    # Lire le prompt
    prompt = read_prompt()

    # G√©n√©rer la vid√©o
    success = generate_video(prompt)

    if success:
        print("\n" + "‚ïê" * 43)
        print("‚úÖ G√©n√©ration termin√©e avec succ√®s!")
        print("‚ïê" * 43)
    else:
        print("\n" + "‚ïê" * 43)
        print("‚ùå La g√©n√©ration a √©chou√©")
        print("‚ïê" * 43)
        sys.exit(1)

if __name__ == "__main__":
    main()
