#!/usr/bin/env python3
"""
Script pour g√©n√©rer une vid√©o avec l'API Sora2
"""

import os
import sys
import requests
from dotenv import load_dotenv
from pathlib import Path
import time
import json
import hashlib
import base64
import argparse

# Charger les variables d'environnement
load_dotenv()

# Configuration
API_KEY = os.getenv("SORA_API_KEY")
MODEL = os.getenv("SORA_MODEL", "sora-2-pro")
DURATION = os.getenv("SORA_DURATION", "8")
SIZE = os.getenv("SORA_SIZE", "1280x720")
REFERENCE_IMAGE = os.getenv("SORA_REFERENCE_IMAGE")

# Variable globale pour suivre l'image de r√©f√©rence utilis√©e
current_reference_image_path = None

# URL de l'API Sora2
API_BASE_URL = "https://api.openai.com/v1/videos"

# Configuration retry
MAX_RETRIES = 3
INITIAL_BACKOFF = 5  # secondes

def save_metadata(video_id, prompt, status, error=None, reference_image_path=None):
    """Sauvegarde les m√©tadonn√©es de la vid√©o pour r√©cup√©ration ult√©rieure"""
    metadata_dir = Path("metadata")
    metadata_dir.mkdir(exist_ok=True)

    metadata = {
        "video_id": video_id,
        "prompt": prompt,
        "model": MODEL,
        "duration": DURATION,
        "size": SIZE,
        "status": status,
        "timestamp": int(time.time()),
        "error": error
    }

    # Ajouter les informations sur l'image de r√©f√©rence si fournie
    global current_reference_image_path
    if current_reference_image_path:
        metadata["reference_image"] = current_reference_image_path

    metadata_file = metadata_dir / f"{video_id}.json"
    with open(metadata_file, "w", encoding="utf-8") as f:
        json.dump(metadata, f, indent=2, ensure_ascii=False)

    return metadata_file

def read_prompt():
    """Lit le prompt depuis le fichier prompt.md"""
    prompt_file = Path("prompt.md")
    if not prompt_file.exists():
        print("Erreur: Le fichier prompt.md n'existe pas")
        sys.exit(1)

    with open(prompt_file, "r", encoding="utf-8") as f:
        content = f.read().strip()
        # Retirer les titres markdown et lignes vides
        lines = [line for line in content.split("\n") if line.strip() and not line.startswith("#")]
        return "\n".join(lines)

def read_reference_image(image_path):
    """Lit une image de r√©f√©rence et la convertit en base64"""
    if not image_path:
        return None

    # V√©rifier si c'est une URL
    if image_path.startswith(('http://', 'https://')):
        print("‚ùå Erreur: Les URLs ne sont pas support√©es pour les images de r√©f√©rence")
        print("   Veuillez placer votre image dans le r√©pertoire 'input_reference/'")
        return None

    # Fichier local - v√©rifier qu'il est dans input_reference/
    image_file = Path(image_path)
    if not image_file.exists():
        print(f"‚ùå Erreur: Le fichier image '{image_path}' n'existe pas")
        return None

    # V√©rifier que le fichier est dans le r√©pertoire input_reference/
    try:
        image_file_abs = image_file.resolve()
        input_ref_dir = Path("input_reference").resolve()
        if not str(image_file_abs).startswith(str(input_ref_dir)):
            print(f"‚ùå Erreur: L'image doit √™tre plac√©e dans le r√©pertoire 'input_reference/'")
            print(f"   Chemin actuel: {image_file}")
            print(f"   R√©pertoire requis: input_reference/")
            return None
    except Exception:
        print(f"‚ùå Erreur: Impossible de v√©rifier le chemin de l'image")
        return None

    # V√©rifier l'extension
    valid_extensions = {'.jpg', '.jpeg', '.png'}
    if image_file.suffix.lower() not in valid_extensions:
        print(f"‚ùå Erreur: Format d'image non support√©. Formats support√©s: {', '.join(valid_extensions)}")
        return None

    try:
        from PIL import Image
        # V√©rifier les dimensions de l'image
        with Image.open(image_file) as img:
            width, height = img.size
            expected_size = SIZE  # Format "1280x720"
            expected_width, expected_height = map(int, expected_size.split('x'))

            print(f"üìè Dimensions de l'image: {width}x{height}")
            print(f"üìè Dimensions requises: {expected_width}x{expected_height}")

            if width != expected_width or height != expected_height:
                print(f"‚ùå Erreur: Les dimensions de l'image ne correspondent pas √† SORA_SIZE={SIZE}")
                print(f"   Image actuelle: {width}x{height}")
                print(f"   Attendu: {expected_width}x{expected_height}")
                print(f"   Veuillez redimensionner l'image ou modifier SORA_SIZE dans le .env")
                return None
            else:
                print(f"‚úÖ Dimensions de l'image correctes")
    except ImportError:
        print("‚ö†Ô∏è  Attention: PIL/Pillow n'est pas install√©. Impossible de v√©rifier les dimensions de l'image.")
        print("   Installez avec: pip install Pillow")
    except Exception as e:
        print(f"‚ö†Ô∏è  Attention: Impossible de v√©rifier les dimensions de l'image: {e}")

    try:
        with open(image_file, "rb") as f:
            image_data = f.read()
    except Exception as e:
        print(f"‚ùå Erreur lors de la lecture du fichier image: {e}")
        return None

    # Encoder en base64
    try:
        base64_image = base64.b64encode(image_data).decode('utf-8')
        print(f"‚úÖ Image de r√©f√©rence charg√©e ({len(image_data):,} bytes)")
        return base64_image
    except Exception as e:
        print(f"‚ùå Erreur lors de l'encodage de l'image: {e}")
        return None

def check_moderation_error(error_response):
    """D√©tecte si l'erreur est li√©e √† la mod√©ration"""
    if not error_response:
        return False

    error_text = str(error_response).lower()
    moderation_keywords = [
        "moderation",
        "content policy",
        "violates",
        "inappropriate",
        "blocked",
        "prohibited"
    ]

    return any(keyword in error_text for keyword in moderation_keywords)

def generate_video(prompt, reference_image_base64=None):
    """G√©n√®re une vid√©o en utilisant l'API Sora2"""
    if not API_KEY or API_KEY == "your_api_key_here":
        print("Erreur: Veuillez configurer votre cl√© API dans le fichier .env")
        sys.exit(1)

    headers = {
        "Authorization": f"Bearer {API_KEY}"
    }

    print(f"G√©n√©ration de la vid√©o avec les param√®tres:")
    print(f"  - Model: {MODEL}")
    print(f"  - Duration: {DURATION}s")
    print(f"  - Size: {SIZE}")
    if reference_image_base64:
        print(f"  - Image de r√©f√©rence: ‚úÖ")
    else:
        print(f"  - Image de r√©f√©rence: ‚ùå")
    print(f"  - Prompt: {prompt[:100]}...")
    
    # Demander confirmation avant l'appel API
    print("\n" + "="*50)
    print("‚ö†Ô∏è  ATTENTION: Cet appel va g√©n√©rer des co√ªts sur votre compte OpenAI")
    print("="*50)
    
    confirmation = input("\nVoulez-vous continuer avec la g√©n√©ration de vid√©o ? (oui/non): ").lower().strip()
    
    if confirmation not in ['oui', 'o', 'yes', 'y']:
        print("‚ùå G√©n√©ration annul√©e par l'utilisateur")
        return None
    
    print("\nEnvoi de la requ√™te √† l'API...")

    # Pr√©parer les donn√©es pour multipart/form-data
    data = {
        "model": MODEL,
        "prompt": prompt,
        "seconds": DURATION,
        "size": SIZE
    }
    
    files = {}
    
    # Ajouter l'image de r√©f√©rence si fournie
    if reference_image_base64:
        # Convertir base64 en bytes pour l'upload
        import base64
        image_data = base64.b64decode(reference_image_base64)
        files["input_reference"] = ("reference_image.jpg", image_data, "image/jpeg")

    try:
        response = requests.post(API_BASE_URL, headers=headers, data=data, files=files)

        # V√©rifier les erreurs de mod√©ration AVANT de facturer
        if response.status_code == 400:
            error_data = response.json() if response.text else {}
            error_msg = error_data.get("error", {}).get("message", response.text)

            if check_moderation_error(error_msg):
                print("\n‚ùå ERREUR DE MOD√âRATION:")
                print(f"   {error_msg}")
                print("\nüí° Suggestions:")
                print("   - Reformulez votre prompt pour √©viter le contenu sensible")
                print("   - √âvitez les descriptions violentes, sexuelles ou inappropri√©es")
                print("   - Utilisez un langage plus neutre et descriptif")
                print("\n‚ö†Ô∏è  IMPORTANT: Vous n'avez PAS √©t√© d√©bit√© car la requ√™te a √©t√© rejet√©e avant la g√©n√©ration")
                return False
            else:
                print(f"\n‚ùå Erreur de requ√™te: {error_msg}")
                return False

        response.raise_for_status()
        result = response.json()
        print(f"R√©ponse de l'API: {result}")

        # L'API retourne un ID de vid√©o
        if "id" in result:
            video_id = result["id"]
            print(f"\n‚úì T√¢che de g√©n√©ration cr√©√©e: {video_id}")
            print("‚è≥ La g√©n√©ration peut prendre quelques minutes...")

            # Sauvegarder les m√©tadonn√©es
            save_metadata(video_id, prompt, "queued")

            return wait_for_completion(video_id, headers, prompt)

        print("Format de r√©ponse inattendu:", result)
        return False

    except requests.exceptions.RequestException as e:
        print(f"\n‚ùå Erreur lors de la requ√™te API: {e}")
        if hasattr(e, 'response') and e.response is not None:
            try:
                error_data = e.response.json()
                error_msg = error_data.get("error", {}).get("message", e.response.text)
                print(f"   D√©tails: {error_msg}")

                if check_moderation_error(error_msg):
                    print("\n‚ö†Ô∏è  Erreur de mod√©ration d√©tect√©e - Vous n'avez pas √©t√© d√©bit√©")
            except:
                print(f"   D√©tails: {e.response.text}")
        return False

def wait_for_completion(video_id, headers, prompt):
    """Attend la compl√©tion d'une t√¢che de g√©n√©ration asynchrone"""
    status_url = f"{API_BASE_URL}/{video_id}"
    content_url = f"{API_BASE_URL}/{video_id}/content"

    timeout_counter = 0
    max_timeout = 600  # 10 minutes (600 secondes / 10 secondes par check)

    while timeout_counter < max_timeout:
        try:
            response = requests.get(status_url, headers=headers)
            response.raise_for_status()
            result = response.json()

            status = result.get("status")
            progress = result.get("progress", 0)
            print(f"üìä Status: {status} - Progression: {progress}%")

            # Mettre √† jour les m√©tadonn√©es
            save_metadata(video_id, prompt, status)

            if status == "completed":
                print(f"\n‚úÖ Vid√©o g√©n√©r√©e avec succ√®s!")
                # T√©l√©charger la vid√©o avec retry
                return download_video_with_retry(content_url, headers, video_id, prompt)

            elif status in ["failed", "error"]:
                error_info = result.get("error", {})
                error_msg = error_info.get("message", "Erreur inconnue")
                error_code = error_info.get("code", "")

                print(f"\n‚ùå Erreur lors de la g√©n√©ration:")
                print(f"   Message: {error_msg}")
                if error_code:
                    print(f"   Code: {error_code}")

                # Sauvegarder l'erreur dans les m√©tadonn√©es
                save_metadata(video_id, prompt, "failed", error=error_msg)

                if check_moderation_error(error_msg):
                    print("\n‚ö†Ô∏è  ATTENTION: Vous avez √©t√© d√©bit√© mais la vid√©o a √©t√© rejet√©e par la mod√©ration")
                    print("   Contactez le support OpenAI pour un remboursement avec cet ID: " + video_id)

                return False

            time.sleep(10)
            timeout_counter += 1

        except requests.exceptions.RequestException as e:
            print(f"\n‚ö†Ô∏è  Erreur lors de la v√©rification du status: {e}")
            if hasattr(e, 'response') and hasattr(e.response, 'text'):
                print(f"   D√©tails: {e.response.text}")

            # Sauvegarder l'√©tat d'erreur
            save_metadata(video_id, prompt, "error", error=str(e))
            print(f"\nüíæ M√©tadonn√©es sauvegard√©es pour r√©cup√©ration: metadata/{video_id}.json")
            return False

    print(f"\n‚è∞ Timeout: La g√©n√©ration prend trop de temps (>{max_timeout * 10}s)")
    print(f"   Video ID: {video_id}")
    print(f"   Vous pouvez v√©rifier manuellement le statut plus tard")
    save_metadata(video_id, prompt, "timeout")
    return False

def download_video_with_retry(content_url, headers, video_id, prompt, max_retries=MAX_RETRIES):
    """T√©l√©charge la vid√©o avec retry en cas d'erreur r√©seau"""
    for attempt in range(max_retries):
        try:
            print(f"\nüì• Tentative de t√©l√©chargement {attempt + 1}/{max_retries}...")

            if download_video_from_api(content_url, headers, video_id):
                save_metadata(video_id, prompt, "downloaded")
                return True

        except Exception as e:
            wait_time = INITIAL_BACKOFF * (2 ** attempt)
            if attempt < max_retries - 1:
                print(f"\n‚ö†Ô∏è  Erreur: {e}")
                print(f"   Nouvelle tentative dans {wait_time}s...")
                time.sleep(wait_time)
            else:
                print(f"\n‚ùå √âchec apr√®s {max_retries} tentatives")
                print(f"   Video ID: {video_id}")
                print(f"   URL: {content_url}")
                print(f"\nüí° Vous pouvez t√©l√©charger manuellement avec:")
                print(f"   curl -H 'Authorization: Bearer YOUR_API_KEY' '{content_url}' > output/{video_id}.mp4")
                save_metadata(video_id, prompt, "download_failed", error=str(e))
                return False

    return False

def download_video_from_api(content_url, headers, video_id):
    """T√©l√©charge la vid√©o g√©n√©r√©e depuis l'API"""
    print("üì• T√©l√©chargement de la vid√©o...")

    response = requests.get(content_url, headers=headers, stream=True, timeout=300)
    response.raise_for_status()

    # Cr√©er le dossier de sortie si n√©cessaire
    output_dir = Path("output")
    output_dir.mkdir(exist_ok=True)

    # Nom du fichier avec timestamp
    timestamp = int(time.time())
    output_file = output_dir / f"video_{video_id}_{timestamp}.mp4"
    temp_file = output_dir / f"video_{video_id}_{timestamp}.mp4.tmp"

    total_size = int(response.headers.get('content-length', 0))
    downloaded = 0
    hasher = hashlib.sha256()

    # T√©l√©charger dans un fichier temporaire
    with open(temp_file, "wb") as f:
        for chunk in response.iter_content(chunk_size=8192):
            if chunk:
                f.write(chunk)
                hasher.update(chunk)
                downloaded += len(chunk)
                if total_size > 0:
                    progress = (downloaded / total_size) * 100
                    print(f"\rüì• T√©l√©chargement: {progress:.1f}% ({downloaded}/{total_size} bytes)", end="", flush=True)

    print()  # Nouvelle ligne apr√®s la barre de progression

    # V√©rifier que le t√©l√©chargement est complet
    if total_size > 0 and downloaded != total_size:
        temp_file.unlink()
        raise Exception(f"T√©l√©chargement incomplet: {downloaded}/{total_size} bytes")

    # V√©rifier que le fichier n'est pas vide
    if downloaded == 0:
        temp_file.unlink()
        raise Exception("Le fichier t√©l√©charg√© est vide")

    # Renommer le fichier temporaire
    temp_file.rename(output_file)

    file_hash = hasher.hexdigest()
    print(f"\n‚úÖ Vid√©o sauvegard√©e: {output_file}")
    print(f"   Taille: {downloaded:,} bytes")
    print(f"   SHA256: {file_hash[:16]}...")

    # Sauvegarder le hash dans les m√©tadonn√©es
    metadata_file = Path("metadata") / f"{video_id}.json"
    if metadata_file.exists():
        with open(metadata_file, "r") as f:
            metadata = json.load(f)
        metadata["file_path"] = str(output_file)
        metadata["file_size"] = downloaded
        metadata["sha256"] = file_hash
        with open(metadata_file, "w") as f:
            json.dump(metadata, f, indent=2, ensure_ascii=False)

    return True

def main():
    parser = argparse.ArgumentParser(description="G√©n√©rateur de vid√©o Sora2 avec support d'image de r√©f√©rence optionnelle")
    parser.add_argument("--reference-image", "-r",
                       help="Chemin ou URL de l'image de r√©f√©rence √† utiliser")

    args = parser.parse_args()

    print("‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê")
    print("   üé¨ G√©n√©rateur de vid√©o Sora2")
    print("‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n")

    # D√©terminer l'image de r√©f√©rence √† utiliser
    global current_reference_image_path
    reference_image_path = args.reference_image or REFERENCE_IMAGE

    if reference_image_path:
        print(f"üñºÔ∏è  Image de r√©f√©rence: {reference_image_path}")
        current_reference_image_path = reference_image_path
        reference_image_base64 = read_reference_image(reference_image_path)
        if reference_image_base64 is None:
            print("‚ùå Impossible de charger l'image de r√©f√©rence, abandon...")
            sys.exit(1)
    else:
        print("‚ÑπÔ∏è  Aucune image de r√©f√©rence sp√©cifi√©e")
        reference_image_base64 = None

    # Lire le prompt
    prompt = read_prompt()

    # G√©n√©rer la vid√©o
    success = generate_video(prompt, reference_image_base64)

    if success:
        print("\n" + "‚ïê" * 43)
        print("‚úÖ G√©n√©ration termin√©e avec succ√®s!")
        print("‚ïê" * 43)
    else:
        print("\n" + "‚ïê" * 43)
        print("‚ùå La g√©n√©ration a √©chou√©")
        print("‚ïê" * 43)
        sys.exit(1)

if __name__ == "__main__":
    main()
